---
description: 
globs: **/*.ts,**/*.tsx,**/*.svelte
alwaysApply: false
---
# 타입스크립트 베스트 프랙티스

## 함수 작성

- **작은 함수 작성**: 함수는 하나의 작업만 수행하도록 작게 유지하세요.
- **순수 함수 지향**: 가능한 한 부작용 없는 순수 함수를 작성하세요.
- **기본 매개변수 활용**: 선택적 매개변수는 기본값과 함께 정의하세요.
- **화살표 함수 사용**: 가능한 한 함수를 화살표 함수로 작성하세요.
- **콜백 중첩 피하기**: 콜백 중첩은 `async/await`나 유틸리티 함수로 평탄화하세요.

## 변수 및 상태 관리

- **const 우선 사용**: 재할당이 필요 없는 변수는 항상 `const`로 선언하세요.
- **let 최소화**: `let`은 꼭 필요한 경우에만 사용하세요. `var`는 사용하지 마세요.
- **전역 변수 피하기**: 전역 변수 사용을 최소화하고 필요하다면 모듈 패턴을 사용하세요.
- **불변성 유지**: 객체와 배열은 불변으로 다루고, 새 객체를 생성하여 변경사항을 적용하세요.
- **구조 분해 할당 활용**: 객체나 배열에서 값을 추출할 때는 구조 분해 할당을 사용하세요.

## 코드 구조화

- **조기 반환**: 복잡한 중첩 조건문 대신 조기 반환 패턴을 사용하세요.
- **삼항 연산자 적절히 사용**: 간단한 조건부 표현식에는 삼항 연산자를 사용하세요.
- **가드 절 패턴**: 예외 케이스를 먼저 처리하여 메인 로직을 깔끔하게 유지하세요.
- **모듈화**: 코드를 작고 재사용 가능한 모듈로 분리하세요.
- **SOLID 원칙 적용**: 단일 책임, 개방/폐쇄, 리스코프 치환, 인터페이스 분리, 의존성 역전 원칙을 적용하세요.

## 성능 최적화

- **루프 최적화**: 큰 배열 처리 시 적절한 메서드(`map`, `filter`, `reduce` 등)를 선택하세요.
- **이벤트 디바운싱/쓰로틀링**: 빈번한 이벤트 핸들러는 디바운스나 쓰로틀 기법을 적용하세요.

## 에러 처리

- **명시적 에러 처리**: 잠재적 오류가 발생할 수 있는 코드는 항상 try-catch로 감싸세요.
- **유의미한 에러 메시지**: 에러 메시지는 구체적이고 행동 가능한 정보를 포함해야 합니다.
- **에러 전파**: 적절한 수준에서 에러를 처리하고, 필요시 상위 레벨로 전파하세요.
- **에러 중앙화**: 애플리케이션 전체적인 에러 처리 전략과 로깅을 구축하세요.

## 코드 가독성

- **일관된 네이밍 컨벤션**: 변수, 함수, 클래스 등에 일관된 네이밍 패턴을 적용하세요.
- **의미있는 이름 사용**: 약어 대신 서술적이고 의미가 명확한 이름을 사용하세요.
- **주석 작성**: 복잡한 로직이나 의도가 명확하지 않은 코드에는 주석을 추가하세요.
- **일관된 코드 스타일**: 들여쓰기, 공백, 괄호 등의 스타일을 일관되게 유지하세요.
- **linter와 formatter 사용**: ESLint, Prettier 등을 사용하여 코드 품질과 일관성을 유지하세요.

## 모던 자바스크립트 기능 활용

- **옵셔널 체이닝**: 중첩된 객체 속성에 안전하게 접근하려면 `?.` 연산자를 사용하세요.
- **Nullish 병합 연산자**: `null`이나 `undefined`에 대한 기본값을 설정할 때 `??` 연산자를 사용하세요.
- **스프레드 연산자**: 객체나 배열을 복사하거나 병합할 때 스프레드 연산자(`...`)를 사용하세요.
- **구조분해 할당**: 객체나 배열에서 특정 값을 추출할 때 구조분해 할당을 사용하세요.

## 타입 정의

- **any 타입 사용 금지**: `any` 타입은 타입 검사를 우회하므로 사용하지 마세요. 대신 명시적인 타입이나 `unknown`을 사용하세요.
- **타입 추론 활용**: 타입 추론이 명확한 경우에는 중복된 타입 선언을 피하세요.
- **유니온 타입 활용**: 여러 타입을 받을 수 있는 경우 `any` 대신 유니온 타입을 사용하세요.
- **제네릭 활용**: 함수나 클래스에서 다양한 타입을 지원해야 할 때는 제네릭을 사용하세요.
- **type vs interface**: 가능한 한 `interface` 대신 `type`을 사용하세요. `type`은 유니온, 교차 타입, 조건부 타입 등에 더 유연하게 활용할 수 있습니다.

## 타입 안전성

- **non-null 단언 최소화**: `!`(non-null 단언 연산자)는 꼭 필요한 경우에만 사용하세요.
- **타입 가드 활용**: 타입 범위를 좁히기 위해 `typeof`, `instanceof`, 사용자 정의 타입 가드 함수를 활용하세요.
- **선택적 체이닝**: 객체가 null 또는 undefined일 수 있는 경우 선택적 체이닝(`?.`)을 사용하세요.
- **Nullish 병합 연산자**: null 또는 undefined 값에 대한 기본값을 설정할 때 `??` 연산자를 사용하세요.

## 코드 구조화

- **작은 타입 설계**: 큰 타입보다 작고 집중된 타입을 설계하고 필요시 교차 타입(`&`)으로 조합하세요.
- **불변성 유지**: 객체와 배열은 가능한 불변으로 다루고, 변경이 필요한 경우 새 객체를 생성하세요.
- **readonly 활용**: 변경되지 않아야 하는 속성이나 배열에는 `readonly` 키워드를 사용하세요.
- **열거형 대신 유니온 리터럴 타입**: 일반적으로 `enum` 대신 문자열 리터럴 유니온 타입을 사용하세요.
- **타입 별칭 활용**: 복잡한 타입이나 재사용 가능한 타입은 타입 별칭으로 추출하세요.

## 함수 타입 정의

- **반환 타입 추론 활용**: 타입스크립트의 반환 타입 추론이 명확한 경우 명시적 반환 타입을 생략해도 됩니다. 복잡한 함수나 제네릭 함수에서는 명시적 반환 타입이 도움이 됩니다.
- **함수 시그니처**: 함수 타입은 화살표 함수 시그니처(`type Fn = (arg: Type) => ReturnType`)를 사용하세요.
- **선택적 매개변수**: 매개변수가 선택적인 경우 `?` 기호를 사용하여 명시하세요.
- **기본 매개변수**: 매개변수에 기본값이 있는 경우 기본 매개변수 구문을 사용하세요.
- **콜백 타입**: 콜백 함수의 타입은 명시적으로 정의하고, 가능하면 함수 타입으로 추출하세요.

## 비동기 코드

- **Promise와 async/await**: 비동기 코드는 가능한 `async/await`를 사용하여 가독성을 높이세요.
- **Promise 반환 타입**: 복잡한 비동기 함수나 제네릭 반환 타입이 필요한 경우 `Promise<T>` 형태로 반환 타입을 명시하세요.
- **에러 처리**: 비동기 코드의 에러는 `try/catch` 블록으로 처리하세요.
- **비동기 반복**: 비동기 배열 처리는 `Promise.all`, `Promise.allSettled` 등을 활용하세요.

## 모듈 및 라이브러리

- **타입 선언 파일 활용**: 외부 라이브러리를 사용할 때는 타입 선언 파일(`.d.ts`)을 함께 설치하세요.
- **import/export 타입**: 타입만 가져오거나 내보낼 때는 `import type`과 `export type`을 사용하세요.
- **타입 확장**: 기존 타입을 확장할 때는 교차 타입(`&`)을 사용하세요.

## 유틸리티 타입 활용

- 내장 유틸리티 타입(`Partial<T>`, `Required<T>`, `Pick<T>`, `Omit<T>`, `Readonly<T>` 등)을 적극 활용하세요.
- 복잡한 타입 변환이나 추출이 필요한 경우 조건부 타입과 매핑된 타입을 사용하세요.

## 유용한 타입스크립트 라이브러리 활용

- 복잡한 타입 정의를 위해 `type-fest` 라이브러리를 활용하세요.
- 복잡한 조건 로직은 `ts-pattern` 라이브러리를 사용한 패턴 매칭으로 단순화하세요.
